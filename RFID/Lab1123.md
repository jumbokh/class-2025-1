
---

# 第 6 週：電子錢包 × 小販機（離線交易與同步）

## 0) 本週成果（驗收標準）

* API：`/wallet/topup`、`/wallet/purchase`、`/wallet/reconcile` 可用
* **去重機制**：相同 `(uid, txn_no)` 不會重複入帳（資料庫唯一索引）
* **離線流程**：伺服器關閉時仍可「購買」→ 產生本地 `journal`；恢復上線後跑 `/wallet/reconcile` 批次同步
* **餘額一致**：對帳後，伺服器餘額與卡端（模擬）餘額一致；不可透支（伺服器拒絕）

---

## 1) 專案結構（新增一個 week6/ 夾）

```
week6/
  .env
  /db     schema.sql   seed.sql
  /server app_wallet.py
  /client wallet_card.py   vending.py   reconcile.py
```

### 1.1 安裝套件（沿用第 5 週虛擬環境）

```bash
pip install Flask==3.0.0 python-dotenv==1.0.1 requests==2.32.3 PyMySQL==1.1.1
```

### 1.2 `.env`（與第 5 週類似）

```ini
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASS=pass123
DB_NAME=rfid_iot

HOST=0.0.0.0
PORT=8001

# 客戶端會讀這個 URL
SERVER_URL=http://127.0.0.1:8001
```

---

## 2) 建資料庫（MySQL）

`db/schema.sql`

```sql
CREATE DATABASE IF NOT EXISTS rfid_iot DEFAULT CHARACTER SET utf8mb4;
USE rfid_iot;

-- 伺服器端的主帳本（以伺服器餘額為準）
CREATE TABLE IF NOT EXISTS cards(
  uid VARCHAR(32) PRIMARY KEY,
  server_balance INT NOT NULL DEFAULT 0,
  last_txn_no BIGINT NOT NULL DEFAULT 0,
  status TINYINT NOT NULL DEFAULT 1
);

-- 交易明細（伺服器）——以 uid + txn_no 去重
CREATE TABLE IF NOT EXISTS txn(
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  uid VARCHAR(32) NOT NULL,
  type ENUM('TOPUP','PURCHASE','ADJUST') NOT NULL,
  amount INT NOT NULL,                -- 入帳金額；購買為負數
  txn_no BIGINT NOT NULL,             -- 客戶端提供或伺服器生成
  ts BIGINT NOT NULL,                 -- 秒級時間戳
  source VARCHAR(32) DEFAULT 'server',
  sig VARCHAR(128) NULL
);
CREATE UNIQUE INDEX uniq_uid_txnno ON txn(uid, txn_no);

-- 可選：以伺服器價格為準（避免客戶端竄改）
CREATE TABLE IF NOT EXISTS products(
  sku VARCHAR(16) PRIMARY KEY,
  name VARCHAR(64),
  price INT NOT NULL
);
```

`db/seed.sql`

```sql
USE rfid_iot;

INSERT INTO cards(uid, server_balance, last_txn_no, status) VALUES
('04aa11bb', 100, 0, 1),
('04bb22cc',  50, 0, 1)
ON DUPLICATE KEY UPDATE server_balance=VALUES(server_balance);

INSERT INTO products(sku, name, price) VALUES
('A01','Sandwich',25),
('A02','Coffee',15),
('A03','Tea',12)
ON DUPLICATE KEY UPDATE price=VALUES(price);
```

執行：

```bash
mysql -u root -p < db/schema.sql
mysql -u root -p < db/seed.sql
```

---

## 3) 伺服器（Flask）：購買、儲值、對帳（去重）

`server/app_wallet.py`

```python
import os, time
from flask import Flask, request, jsonify
import pymysql
from dotenv import load_dotenv

load_dotenv()
DB_HOST=os.getenv("DB_HOST","localhost")
DB_PORT=int(os.getenv("DB_PORT","3306"))
DB_USER=os.getenv("DB_USER","root")
DB_PASS=os.getenv("DB_PASS","pass123")
DB_NAME=os.getenv("DB_NAME","rfid_iot")

def get_conn():
    # 關鍵：使用交易（autocommit=False），以便 SELECT ... FOR UPDATE
    return pymysql.connect(host=DB_HOST, port=DB_PORT, user=DB_USER, password=DB_PASS,
                           database=DB_NAME, autocommit=False,
                           cursorclass=pymysql.cursors.DictCursor)

app = Flask(__name__)

def ensure_card(conn, uid):
    with conn.cursor() as c:
        c.execute("SELECT * FROM cards WHERE uid=%s FOR UPDATE", (uid,))
        row = c.fetchone()
        if not row:
            c.execute("INSERT INTO cards(uid, server_balance, last_txn_no, status) VALUES (%s,0,0,1)", (uid,))
            conn.commit()

def exists_txn(conn, uid, txn_no):
    with conn.cursor() as c:
        c.execute("SELECT 1 FROM txn WHERE uid=%s AND txn_no=%s", (uid, txn_no))
        return c.fetchone() is not None

def insert_txn_and_update_balance(conn, uid, amount, txn_no, typ):
    # 鎖定卡片行避免競態
    with conn.cursor() as c:
        c.execute("SELECT server_balance, last_txn_no FROM cards WHERE uid=%s FOR UPDATE", (uid,))
        row = c.fetchone()
        if not row:
            raise ValueError("card-not-found")
        bal = int(row["server_balance"])
        # 不能透支
        if bal + amount < 0:
            return False, "insufficient"

        # 記明細
        ts = int(time.time())
        c.execute("""INSERT INTO txn(uid, type, amount, txn_no, ts, source)
                     VALUES (%s,%s,%s,%s,%s,'server')""",
                  (uid, typ, amount, txn_no, ts))
        # 更新餘額與 last_txn_no
        c.execute("""UPDATE cards SET server_balance=server_balance+%s,
                                     last_txn_no=GREATEST(last_txn_no,%s)
                     WHERE uid=%s""", (amount, txn_no, uid))
        conn.commit()
        return True, {"balance": bal + amount, "ts": ts}

@app.post("/wallet/topup")
def wallet_topup():
    data = request.get_json(force=True)
    uid = (data.get("uid") or "").lower()
    amount = int(data.get("amount", 0))
    txn_no = int(data.get("txn_no") or time.time())
    if not uid or amount <= 0: return jsonify({"ok":False,"reason":"bad-args"}), 400

    conn = get_conn()
    try:
        ensure_card(conn, uid)
        if exists_txn(conn, uid, txn_no): conn.rollback(); return jsonify({"ok":False,"reason":"duplicate"})
        ok, info = insert_txn_and_update_balance(conn, uid, amount, txn_no, "TOPUP")
        if not ok: conn.rollback(); return jsonify({"ok":False,"reason":info})
        return jsonify({"ok":True, "uid":uid, "txn_no":txn_no, **info})
    except Exception as e:
        conn.rollback(); return jsonify({"ok":False,"reason":str(e)}), 500
    finally:
        conn.close()

@app.post("/wallet/purchase")
def wallet_purchase():
    data = request.get_json(force=True)
    uid = (data.get("uid") or "").lower()
    items = data.get("items", [])  # [{"sku":"A01","qty":1}]
    txn_no = int(data.get("txn_no") or time.time())
    if not uid or not items: return jsonify({"ok":False,"reason":"bad-args"}), 400

    conn = get_conn()
    try:
        ensure_card(conn, uid)
        if exists_txn(conn, uid, txn_no): conn.rollback(); return jsonify({"ok":False,"reason":"duplicate"})

        # 以伺服器價格為準
        total = 0
        with conn.cursor() as c:
            for it in items:
                c.execute("SELECT price FROM products WHERE sku=%s", (it["sku"],))
                row = c.fetchone()
                if not row: conn.rollback(); return jsonify({"ok":False,"reason":f"sku-not-found:{it['sku']}"})
                price = int(row["price"])
                qty = int(it.get("qty",1))
                total += price * qty

        ok, info = insert_txn_and_update_balance(conn, uid, -total, txn_no, "PURCHASE")
        if not ok: conn.rollback(); return jsonify({"ok":False,"reason":info})
        return jsonify({"ok":True, "uid":uid, "amount":-total, "txn_no":txn_no, **info})
    except Exception as e:
        conn.rollback(); return jsonify({"ok":False,"reason":str(e)}), 500
    finally:
        conn.close()

@app.post("/wallet/reconcile")
def wallet_reconcile():
    """ 批次補登：每筆包含 {uid,type,amount,txn_no,ts}；以 (uid, txn_no) 去重 """
    payload = request.get_json(force=True)
    batch = payload.get("batch", [])
    applied = 0; skipped = 0
    conn = get_conn()
    try:
        for t in batch:
            uid = (t.get("uid") or "").lower()
            amount = int(t.get("amount", 0))
            txn_no = int(t.get("txn_no", 0))
            typ = t.get("type","ADJUST")
            if not uid or not txn_no: skipped += 1; continue
            ensure_card(conn, uid)
            if exists_txn(conn, uid, txn_no): conn.rollback(); skipped += 1; continue
            ok, info = insert_txn_and_update_balance(conn, uid, amount, txn_no, typ)
            if ok: applied += 1
            else: skipped += 1
        return jsonify({"ok":True, "applied":applied, "skipped":skipped})
    except Exception as e:
        conn.rollback(); return jsonify({"ok":False,"reason":str(e)}), 500
    finally:
        conn.close()

@app.get("/wallet/balance")
def wallet_balance():
    uid = (request.args.get("uid") or "").lower()
    if not uid: return jsonify({"ok":False,"reason":"bad-args"}), 400
    conn = get_conn()
    try:
        with conn.cursor() as c:
            c.execute("SELECT server_balance FROM cards WHERE uid=%s", (uid,))
            row = c.fetchone()
        conn.commit()
        if not row: return jsonify({"ok":False,"reason":"not-found"}), 404
        return jsonify({"ok":True, "uid":uid, "server_balance": int(row["server_balance"])})
    finally:
        conn.close()

if __name__ == "__main__":
    host=os.getenv("HOST","0.0.0.0"); port=int(os.getenv("PORT","8001"))
    app.run(host=host, port=port, debug=True)
```

啟動伺服器：

```bash
python server/app_wallet.py
# http://127.0.0.1:8001
```

---

## 4) 客戶端（卡端模擬＋販賣機＋對帳）

### 4.1 卡端帳本（本地 JSON＋流水號）

`client/wallet_card.py`

```python
import json, os, time, itertools
from pathlib import Path

STORE = Path(__file__).parent / "card_store.json"

def load_store():
    if STORE.exists(): return json.loads(STORE.read_text("utf-8"))
    # 初始卡端資料（示範）
    return {"uid":"04aa11bb","balance":100,"last_txn_no":0,"journal":[]}

def save_store(d): STORE.write_text(json.dumps(d, ensure_ascii=False, indent=2), "utf-8")

def next_txn_no(d): return max(int(d.get("last_txn_no",0))+1, int(time.time()))

def purchase_local(amount, txn_no=None):
    """ 在離線時先扣本地餘額並寫 journal（金額為正數消費額） """
    d = load_store()
    txn_no = txn_no or next_txn_no(d)
    if d["balance"] - amount < 0:
        print("本地餘額不足，取消購買"); return False
    d["balance"] -= amount
    d["last_txn_no"] = max(int(d["last_txn_no"]), int(txn_no))
    d["journal"].append({"uid":d["uid"], "type":"PURCHASE", "amount":-amount,
                         "txn_no":int(txn_no), "ts":int(time.time())})
    save_store(d)
    print("離線購買已記錄，txn_no=", txn_no)
    return True

if __name__ == "__main__":
    print("初始：", load_store())
```

### 4.2 小販機（線上優先；失敗就離線記帳）

`client/vending.py`

```python
import os, time, json, requests
from pathlib import Path
from dotenv import load_dotenv
load_dotenv()

SERVER_URL=os.getenv("SERVER_URL","http://127.0.0.1:8001")
STORE = Path(__file__).parent / "card_store.json"

def load_store(): return json.loads(STORE.read_text("utf-8"))
def save_store(d): STORE.write_text(json.dumps(d, indent=2), "utf-8")

def buy(items):
    """ items 例如: [{"sku":"A01","qty":1},{"sku":"A02","qty":2}] """
    d = load_store()
    txn_no = max(int(d["last_txn_no"])+1, int(time.time()))

    try:
        r = requests.post(f"{SERVER_URL}/wallet/purchase", json={"uid": d["uid"], "items": items, "txn_no": txn_no}, timeout=3)
        data = r.json()
        if data.get("ok"):
            # 伺服器成功 → 同步本地餘額
            d["last_txn_no"] = max(int(d["last_txn_no"]), int(txn_no))
            # 伺服器回應沒有直接給餘額，這裡直接查詢
            bal = requests.get(f"{SERVER_URL}/wallet/balance", params={"uid": d["uid"]}, timeout=3).json().get("server_balance", d["balance"])
            d["balance"] = bal
            save_store(d)
            print("線上購買成功:", data); return True
        else:
            raise RuntimeError(data.get("reason"))
    except Exception as e:
        # 改為離線記帳：先根據伺服器價目估總價的作法改成——直接詢問失敗就不查
        price_map = {"A01":25,"A02":15,"A03":12}
        total = sum(price_map.get(it["sku"],0)*int(it.get("qty",1)) for it in items)
        if d["balance"] - total < 0:
            print("離線也不足額，取消"); return False
        d["balance"] -= total
        d["last_txn_no"] = max(int(d["last_txn_no"]), int(txn_no))
        d.setdefault("journal", []).append({"uid":d["uid"], "type":"PURCHASE",
                                            "amount":-total, "txn_no":int(txn_no), "ts":int(time.time())})
        save_store(d)
        print("伺服器無法連線，已離線記帳:", total, "txn_no=", txn_no)
        return True

if __name__ == "__main__":
    # 範例：買一份三明治與兩杯咖啡
    buy([{"sku":"A01","qty":1},{"sku":"A02","qty":2}])
```

### 4.3 對帳器：把 journal 批次送回伺服器

`client/reconcile.py`

```python
import os, json, requests
from pathlib import Path
from dotenv import load_dotenv
load_dotenv()

SERVER_URL=os.getenv("SERVER_URL","http://127.0.0.1:8001")
STORE = Path(__file__).parent / "card_store.json"

def load_store(): return json.loads(STORE.read_text("utf-8"))
def save_store(d): STORE.write_text(json.dumps(d, ensure_ascii=False, indent=2), "utf-8")

def reconcile():
    d = load_store()
    batch = d.get("journal", [])
    if not batch:
        print("無需對帳"); return
    try:
        r = requests.post(f"{SERVER_URL}/wallet/reconcile", json={"batch":batch}, timeout=5)
        data = r.json()
        print("對帳結果:", data)
        if data.get("ok"):
            # 清空 journal，並同步伺服器餘額
            d["journal"] = []
            bal = requests.get(f"{SERVER_URL}/wallet/balance", params={"uid": d["uid"]}, timeout=5).json().get("server_balance", d["balance"])
            d["balance"] = bal
            save_store(d)
    except Exception as e:
        print("對帳失敗:", e)

if __name__ == "__main__":
    reconcile()
```

---

## 5) 測試腳本（建議步驟）

### 5.1 啟動伺服器

```bash
python server/app_wallet.py
```

### 5.2 線上購買（成功）

```bash
# 以伺服器價目計算：A01=25, A02=15
python client/vending.py
# 觀察輸出；再查餘額：
curl "http://127.0.0.1:8001/wallet/balance?uid=04aa11bb"
```

### 5.3 人為「斷線」→ 離線購買

* 暫停伺服器（Ctrl+C），或把 `.env` 的 `SERVER_URL` 暫時改成錯誤位址
* 再執行：

```bash
python client/vending.py
# 會顯示「伺服器無法連線，已離線記帳」，journal 產生在 client/card_store.json
```

### 5.4 恢復上線 → 對帳

* 重新啟動伺服器

```bash
python server/app_wallet.py
python client/reconcile.py
curl "http://127.0.0.1:8001/wallet/balance?uid=04aa11bb"
```

**預期**：`applied` > 0、`skipped` 正常；餘額扣到正確值；同一筆再對帳不會重複（`skipped` 增加）。

### 5.5 例外測試

* 重複送相同 `txn_no` → 應 `duplicate` 或在 `/wallet/reconcile` 中被 `skipped`
* 透支測試：讓卡端餘額不足 → 伺服器應回 `insufficient`，離線購買應被本地端阻擋（或教師可允許本地負值、伺服器拒絕後再補正）

---

## 6) 驗收與加分項

* **必做**：去重生效；離線→上線對帳成功；不可透支
* **加分**（任選）

  1. 加入 `/wallet/statement?uid=&from=&to=` 明細查詢
  2. 對帳結果寫入伺服器「對帳報表」表格（applied/skipped 計數）
  3. 本地 `journal` 加上簡易簽章（如 SHA-256(uid|txn_no|amount)）並在伺服器驗證

---

## 7) 交付清單

* 專案資料夾（含程式碼與 `.env.sample`）
* 測試截圖：

  * 線上購買成功回應
  * 斷線時離線記帳（card_store.json 含 journal）
  * 對帳結果（applied/skipped）＋ 對帳後餘額查詢
* README：操作步驟（啟動、斷線模擬、對帳）
* （可選）30–60 秒 Demo 影片

---
