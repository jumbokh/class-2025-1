
---

# 第 5 週：門禁＋出缺勤（Whitelist＋Anti-passback＋即時看板）

## 0) 成果目標（本週驗收）

* 刷卡事件 → **MQTT** → **Flask /auth** → **MySQL** → **即時看板（Streamlit）** 全流程打通
* 白名單驗證（users 表）＋**Anti-passback**（10 秒內同向連刷拒絕）
* 看板可顯示：在線人數、最近紀錄（20 筆）、今日每小時刷卡數折線圖

---

## 1) 先決條件

* Python 3.9+、MySQL 8 / MariaDB、mosquitto（MQTT Broker）、ACR122U 驅動（PC/SC）
* `pip install` 會用到：`Flask`、`python-dotenv`、`requests`、`PyMySQL`、`paho-mqtt`、`streamlit`、（實機讀卡才需）`pyscard`

快速安裝：

```bash
python -m venv .venv
# Windows
.venv\Scripts\activate
# macOS/Linux
source .venv/bin/activate

pip install Flask==3.0.0 python-dotenv==1.0.1 requests==2.32.3 PyMySQL==1.1.1 paho-mqtt==1.6.1 streamlit==1.39.0 pyscard==2.0.7
```

---

## 2) 專案結構（在空資料夾建立）

```
week5/
  .env                # 待會複製 .env.sample 另存
  .env.sample
  /db/    schema.sql  seed.sql
  /server app.py
  /guard  bridge.py
  /reader acr122u_reader.py  sim_reader.py
  /web    app.py
```

### `.env.sample`（先存成 `.env`，必要時修改）

```ini
# Database
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASS=pass123
DB_NAME=rfid_iot

# Server
HOST=0.0.0.0
PORT=8000
ANTI_PASSBACK_SECONDS=10

# MQTT
MQTT_HOST=localhost
MQTT_PORT=1883
MQTT_TOPIC_ENTRY=rfid/door/entry
MQTT_TOPIC_ACK=rfid/door/ack
READER_ID=gateA

# Client URLs
SERVER_URL=http://127.0.0.1:8000
```

---

## 3) 建資料庫（MySQL）

`db/schema.sql`

```sql
CREATE DATABASE IF NOT EXISTS rfid_iot DEFAULT CHARACTER SET utf8mb4;
USE rfid_iot;

CREATE TABLE IF NOT EXISTS users(
  uid VARCHAR(32) PRIMARY KEY,
  name VARCHAR(64),
  dept VARCHAR(64),
  status TINYINT DEFAULT 1
);

CREATE TABLE IF NOT EXISTS access_log(
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  uid VARCHAR(32),
  direction ENUM('IN','OUT'),
  ts BIGINT,
  reader_id VARCHAR(32)
);
```

`db/seed.sql`（先用示範 UID，可之後改成自己卡的 UID）

```sql
USE rfid_iot;
INSERT INTO users(uid,name,dept,status) VALUES
('04aa11bb','Student A','AI Dept',1),
('04bb22cc','Student B','AI Dept',1)
ON DUPLICATE KEY UPDATE name=VALUES(name), dept=VALUES(dept), status=VALUES(status);
```

執行：

```bash
mysql -u root -p < db/schema.sql
mysql -u root -p < db/seed.sql
```

---

## 4) 後端 API（Flask + MySQL）

`server/app.py`

```python
import os, time
from flask import Flask, request, jsonify
import pymysql
from dotenv import load_dotenv

load_dotenv()

DB_HOST=os.getenv("DB_HOST","localhost")
DB_PORT=int(os.getenv("DB_PORT","3306"))
DB_USER=os.getenv("DB_USER","root")
DB_PASS=os.getenv("DB_PASS","pass123")
DB_NAME=os.getenv("DB_NAME","rfid_iot")
ANTI_PASSBACK_SECONDS=int(os.getenv("ANTI_PASSBACK_SECONDS","10"))

def db():
    return pymysql.connect(host=DB_HOST, port=DB_PORT, user=DB_USER,
                           password=DB_PASS, database=DB_NAME,
                           autocommit=True, cursorclass=pymysql.cursors.DictCursor)

def is_whitelisted(uid):
    with db().cursor() as c:
        c.execute("SELECT 1 FROM users WHERE uid=%s AND status=1", (uid,))
        return c.fetchone() is not None

def last_state(uid):
    with db().cursor() as c:
        c.execute("SELECT direction, ts FROM access_log WHERE uid=%s ORDER BY ts DESC LIMIT 1", (uid,))
        row = c.fetchone()
        return (row["direction"], row["ts"]) if row else (None, 0)

def insert_log(uid, direction, ts, reader_id):
    with db().cursor() as c:
        c.execute("INSERT INTO access_log(uid,direction,ts,reader_id) VALUES (%s,%s,%s,%s)",
                  (uid, direction, ts, reader_id))

def decide_direction(last_dir):
    return "OUT" if last_dir == "IN" else "IN"

app = Flask(__name__)

@app.post("/auth/checkCard")
def check_card():
    data = request.get_json(force=True)
    uid = (data.get("uid") or "").lower()
    reader_id = data.get("reader_id","gateA")
    ts = int(data.get("ts", time.time()))
    if not uid:
        return jsonify({"allow": False, "dir": None, "reason":"no-uid"}), 400

    if not is_whitelisted(uid):
        return jsonify({"allow": False, "dir": None, "reason":"not-whitelisted"})

    last_dir, last_ts = last_state(uid)
    new_dir = decide_direction(last_dir) if last_dir else "IN"

    if last_dir == new_dir and (ts - int(last_ts)) < ANTI_PASSBACK_SECONDS:
        return jsonify({"allow": False, "dir": new_dir, "reason":"anti-passback"})

    insert_log(uid, new_dir, ts, reader_id)
    return jsonify({"allow": True, "dir": new_dir, "reason":"ok"})

@app.get("/report/now_in")
def report_now_in():
    with db().cursor() as c:
        c.execute("""
        SELECT x.uid
        FROM (
          SELECT uid,
                 MAX(CASE WHEN direction='IN'  THEN ts ELSE 0 END) AS last_in,
                 MAX(CASE WHEN direction='OUT' THEN ts ELSE 0 END) AS last_out
          FROM access_log GROUP BY uid
        ) x WHERE x.last_in > x.last_out
        """)
        rows = c.fetchall()
    return jsonify({"count": len(rows), "uids": [r["uid"] for r in rows]})

@app.get("/report/recent")
def report_recent():
    with db().cursor() as c:
        c.execute("SELECT uid, direction, ts, reader_id FROM access_log ORDER BY ts DESC LIMIT 20")
        rows = c.fetchall()
    return jsonify(rows)

@app.get("/report/today_count")
def report_today_count():
    with db().cursor() as c:
        c.execute("""
        SELECT FROM_UNIXTIME(ts, '%H') AS hour, COUNT(*) AS cnt
        FROM access_log
        WHERE DATE(FROM_UNIXTIME(ts)) = CURDATE()
        GROUP BY hour ORDER BY hour
        """)
        rows = c.fetchall()
    return jsonify(rows)

if __name__ == "__main__":
    host=os.getenv("HOST","0.0.0.0")
    port=int(os.getenv("PORT","8000"))
    app.run(host=host, port=port, debug=True)
```

啟動：

```bash
python server/app.py
# http://127.0.0.1:8000
```

---

## 5) 啟動 MQTT Broker（mosquitto）

```bash
# Windows 安裝版可直接以服務啟動；或手動
mosquitto -p 1883
```

---

## 6) Guard：接 MQTT → 呼叫 /auth → 回傳 ACK

`guard/bridge.py`

```python
import os, json, requests
import paho.mqtt.client as mqtt
from dotenv import load_dotenv
load_dotenv()

MQTT_HOST=os.getenv("MQTT_HOST","localhost")
MQTT_PORT=int(os.getenv("MQTT_PORT","1883"))
TOPIC_ENTRY=os.getenv("MQTT_TOPIC_ENTRY","rfid/door/entry")
TOPIC_ACK=os.getenv("MQTT_TOPIC_ACK","rfid/door/ack")
SERVER_URL=os.getenv("SERVER_URL","http://127.0.0.1:8000")

def on_connect(client, userdata, flags, rc, properties=None):
    print("MQTT connected", rc)
    client.subscribe(TOPIC_ENTRY)

def on_message(client, userdata, msg):
    try:
        payload = json.loads(msg.payload.decode())
        r = requests.post(f"{SERVER_URL}/auth/checkCard", json=payload, timeout=5)
        data = r.json()
        ack = { **payload, **data }
        client.publish(TOPIC_ACK, json.dumps(ack), qos=0)
        print("ACK:", ack)
    except Exception as e:
        print("ERR:", e)

if __name__ == "__main__":
    client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
    client.on_connect = on_connect
    client.on_message = on_message
    client.connect(MQTT_HOST, MQTT_PORT, 60)
    client.loop_forever()
```

啟動：

```bash
python guard/bridge.py
```

---

## 7) 讀卡端（二選一）

### (A) 實機 ACR122U（pyscard）

`reader/acr122u_reader.py`

```python
import os, time, json
from smartcard.System import readers
from smartcard.Exceptions import NoCardException
import paho.mqtt.client as mqtt
from dotenv import load_dotenv
load_dotenv()

MQTT_HOST=os.getenv("MQTT_HOST","localhost")
MQTT_PORT=int(os.getenv("MQTT_PORT","1883"))
TOPIC_ENTRY=os.getenv("MQTT_TOPIC_ENTRY","rfid/door/entry")
READER_ID=os.getenv("READER_ID","gateA")

def get_uid(connection):
    # APDU: FF CA 00 00 00
    data, sw1, sw2 = connection.transmit([0xFF,0xCA,0x00,0x00,0x00])
    if sw1 == 0x90 and sw2 == 0x00:
        return "".join(f"{b:02x}" for b in data)
    return None

if __name__ == "__main__":
    rlist = readers()
    if not rlist:
        print("No readers found."); raise SystemExit(1)
    r = rlist[0]
    client = mqtt.Client(); client.connect(MQTT_HOST, MQTT_PORT, 60)
    print("Using reader:", r)
    while True:
        try:
            conn = r.createConnection(); conn.connect()
            uid = get_uid(conn)
            if uid:
                payload = {"uid": uid, "ts": int(time.time()), "reader_id": READER_ID}
                client.publish(TOPIC_ENTRY, json.dumps(payload))
                print("Published:", payload)
                time.sleep(1.0)
        except NoCardException:
            time.sleep(0.2)
        except Exception as e:
            print("Error:", e); time.sleep(1.0)
```

### (B) 模擬讀卡

`reader/sim_reader.py`

```python
import os, time, json, random
import paho.mqtt.client as mqtt
from dotenv import load_dotenv
load_dotenv()

MQTT_HOST=os.getenv("MQTT_HOST","localhost")
MQTT_PORT=int(os.getenv("MQTT_PORT","1883"))
TOPIC_ENTRY=os.getenv("MQTT_TOPIC_ENTRY","rfid/door/entry")
READER_ID=os.getenv("READER_ID","gateA")

def random_uid():
    return "04" + "".join(f"{random.randint(0,255):02x}" for _ in range(3))

if __name__ == "__main__":
    client = mqtt.Client(); client.connect(MQTT_HOST, MQTT_PORT, 60)
    print("Sim reader started. Ctrl+C to stop.")
    while True:
        uid = random.choice(["04aa11bb","04bb22cc", random_uid()])
        payload = {"uid": uid, "ts": int(time.time()), "reader_id": READER_ID}
        client.publish(TOPIC_ENTRY, json.dumps(payload))
        print("Published:", payload)
        time.sleep(2)
```

啟動其一：

```bash
# 實機
python reader/acr122u_reader.py
# 或 模擬
python reader/sim_reader.py
```

---

## 8) 即時看板（Streamlit）

`web/app.py`

```python
import os, requests, pandas as pd, streamlit as st

SERVER_URL=os.getenv("SERVER_URL","http://127.0.0.1:8000")

st.set_page_config(page_title="RFID 即時看板", layout="wide")
st.title("RFID 門禁/出缺勤 即時看板")

col1, col2 = st.columns(2)

with col1:
    try:
        now_in = requests.get(f"{SERVER_URL}/report/now_in", timeout=5).json()
        st.metric("目前在線人數", now_in.get("count",0))
        st.write("UIDs:", now_in.get("uids", []))
    except Exception as e:
        st.error(f"now_in 失敗：{e}")

with col2:
    try:
        recent = requests.get(f"{SERVER_URL}/report/recent", timeout=5).json()
        st.subheader("最近 20 筆")
        st.dataframe(pd.DataFrame(recent))
    except Exception as e:
        st.error(f"recent 失敗：{e}")

st.divider()
try:
    today = requests.get(f"{SERVER_URL}/report/today_count", timeout=5).json()
    if today:
        df = pd.DataFrame(today)
        df["hour"] = df["hour"].astype(int)
        df = df.sort_values("hour")
        st.subheader("今日刷卡數（每小時）")
        st.line_chart(df.set_index("hour")["cnt"])
    else:
        st.info("今日尚無資料")
except Exception as e:
    st.error(f"今日統計失敗：{e}")

# 5 秒自動刷新
import time as _t
st.caption("每 5 秒自動刷新")
_t.sleep(5); st.rerun()
```

啟動：

```bash
streamlit run web/app.py
```

---

## 9) 測試步驟（必做）

1. **白名單測試**：用 `seed.sql` 內的 UID 刷卡 → 應允許；換成未註冊的 UID → 應拒絕（`reason: not-whitelisted`）。
2. **Anti-passback**：同一張卡連續兩次同向（10 秒內）→ 第二次應拒絕（`reason: anti-passback`）。
3. **看板**：在線人數會變化、最近紀錄更新、今日每小時曲線有資料。
4. **API 快測**：

   ```bash
   curl -X POST http://127.0.0.1:8000/auth/checkCard -H "Content-Type: application/json" \
     -d "{\"uid\":\"04aa11bb\",\"reader_id\":\"gateA\",\"ts\":$(date +%s)}"
   curl http://127.0.0.1:8000/report/now_in
   curl http://127.0.0.1:8000/report/recent
   curl http://127.0.0.1:8000/report/today_count
   ```

---

## 10) 本週提交

* 架構圖（含 Reader→MQTT→Server→DB→Dashboard 流程）
* Anti-passback 測試截圖或說明（含失敗重現）
* 當日出缺勤匯總（SQL/查詢結果或 CSV）
* README（如何啟動各模組）＋ 30 秒 Demo 錄影（可選）

---
